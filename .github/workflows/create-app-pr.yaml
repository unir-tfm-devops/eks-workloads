name: "Create Application PR"
on:
  issues:
    types: [opened, reopened]

jobs:
  extract_info:
    name: Extract Issue Information
    if: contains(github.event.issue.labels.*.name, 'new-app')
    runs-on: ubuntu-latest
    outputs:
      application-name: ${{ steps.extract_info.outputs.APPLICATION_NAME }}
      repository-name: ${{ steps.extract_info.outputs.REPOSITORY_NAME }}
      environment: ${{ steps.extract_info.outputs.ENVIRONMENT }}
      helm-chart-name: ${{ steps.extract_info.outputs.HELM_CHART_NAME }}
      helm-path: ${{ steps.extract_info.outputs.HELM_PATH }}
      app-version: ${{ steps.extract_info.outputs.APP_VERSION }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Parse Issue Body
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          echo "$ISSUE_BODY" > issue_body.md
          python scripts/extract-app-info.py issue_body.md

      - name: Extract Repo Information
        id: extract_info
        run: |
          echo "APPLICATION_NAME=$(grep 'Application Name:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT
          echo "REPOSITORY_NAME=$(grep 'Repository Name:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT
          echo "HELM_CHART_NAME=$(grep 'Helm Chart Name:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT
          echo "HELM_PATH=$(grep 'Helm Path:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT
          echo "APP_VERSION=$(grep 'Application Version:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT
          echo "ENVIRONMENT=$(grep 'Environment:' extracted_info.txt | cut -d':' -f2- | xargs)" >> $GITHUB_OUTPUT

      - name: Print Extracted Information
        run: |
          echo "Application Name: ${{ steps.extract_info.outputs.APPLICATION_NAME }}"
          echo "Repository Name: ${{ steps.extract_info.outputs.REPOSITORY_NAME }}"
          echo "Helm Chart Name: ${{ steps.extract_info.outputs.HELM_CHART_NAME }}"
          echo "Helm Path: ${{ steps.extract_info.outputs.HELM_PATH }}"
          echo "Application Version: ${{ steps.extract_info.outputs.APP_VERSION }}"
          echo "Environment: ${{ steps.extract_info.outputs.ENVIRONMENT }}"

  argo-test-changes:
    name: ArgoCD App Test Changes
    if: ${{ needs.extract_info.outputs.environment == 'test' || needs.extract_info.outputs.environment == 'both' }}
    needs: [extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Modify values.yaml for Test Environment
        run: |
          # Generate the application name for test environment
          APP_NAME="${{ needs.extract_info.outputs.application-name }}-test"

          # Use yq to add the new application configuration
          yq eval ".applications.$APP_NAME = {\"project\": \"default\", \"source\": {\"path\": \"environments/test/applications/${{ needs.extract_info.outputs.application-name }}\"}, \"destination\": {\"namespace\": \"test\"}}" -i environments/test/configuration/values.yaml

      - name: Commit changes
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository }}
          git checkout -b feature/new-application-${{ env.NAME }}-test
          git add environments/test/configuration/values.yaml
          git commit -m "Add ${{ needs.extract_info.outputs.application-name }} ArgoCD app to test environment"
          git push origin feature/new-application-${{ env.NAME }}-test

  app-config-test-changes:
    name: Application Config Test Changes
    needs: [argo-test-changes, extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Create Application Chart.yaml
        run: |
          # Create the application directory
          mkdir -p environments/test/applications/${{ needs.extract_info.outputs.application-name }}

          # Create Chart.yaml
          cat > environments/test/applications/${{ needs.extract_info.outputs.application-name }}/Chart.yaml << EOF
          apiVersion: v2
          name: ${{ needs.extract_info.outputs.application-name }}
          version: 1.0.0
          description: Helm chart for ${{ needs.extract_info.outputs.application-name }} deployment
          dependencies:
            - name: ${{ needs.extract_info.outputs.helm-chart-name }}
              version: ${{ needs.extract_info.outputs.app-version }}
              repository: "http://3.238.99.68"
          EOF

      - name: Create Application values.yaml
        run: |
          # Clone the original repository to get the values.yaml
          git clone https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/unir-tfm-devops/${{ needs.extract_info.outputs.repository-name }}.git temp-repo
          cd temp-repo

          # Copy the values.yaml from the helm-chart-path and wrap it under the app name
          if [ -f ".${{ needs.extract_info.outputs.helm-path }}/values.yaml" ]; then
            # Use yq to create a new values.yaml with the app name as root key containing the original content
            yq eval ".${{ needs.extract_info.outputs.application-name }} = load(\".${{ needs.extract_info.outputs.helm-path }}/values.yaml\")" -n > ../environments/test/applications/${{ needs.extract_info.outputs.application-name }}/values.yaml
            echo "Successfully copied and wrapped values.yaml from ${{ needs.extract_info.outputs.helm-path }}"
          else
            echo "Error: values.yaml not found at ${{ needs.extract_info.outputs.helm-path }}/values.yaml"
            exit 1
          fi

          # Clean up
          cd ..
          rm -rf temp-repo

      - name: Commit Application Config Changes
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository }}

          # Checkout the existing branch and pull latest changes
          git fetch origin
          git checkout feature/new-application-${{ env.NAME }}-test
          git pull origin feature/new-application-${{ env.NAME }}-test

          git add environments/test/applications/${{ needs.extract_info.outputs.application-name }}/
          git commit -m "Add ${{ needs.extract_info.outputs.application-name }} application configuration for test environment"
          git push origin feature/new-application-${{ env.NAME }}-test

  create-test-pr:
    name: Create Test PR
    needs: [app-config-test-changes, extract_info]
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ env.PR_URL }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Create Pull Request
        id: create_pr
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PR_URL=$(gh pr create \
            -B main \
            -H feature/new-application-${{ env.NAME }}-test \
            -t "Add new application to test environment: ${{ env.NAME }}" \
            -b "### Summary
            This PR adds a new application as requested in [Issue #${{ env.ISSUE_NUMBER }}](${{ env.ISSUE_URL }}).

            **Application Name:** ${{ env.NAME }}
            **Environment:** test

            ### Changes Made
            - Added ArgoCD application configuration to test environment
            - Created application Chart.yaml with dependencies
            - Created application values.yaml from source repository

            ### Checklist
            - [ ] Verify application name and configuration
            - [ ] Confirm Helm chart dependencies are correct
            - [ ] Validate ArgoCD application syntax
            - [ ] Merge once validated

            Closes #${{ env.ISSUE_NUMBER }}")

          echo "PR_URL=$PR_URL" >> $GITHUB_ENV

  comment-on-issue-test:
    name: Comment on Issue Test PR
    needs: [create-test-pr]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Comment on Issue
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          TEST_PR_URL: ${{ needs.create-test-pr.outputs.pr_url }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "✅ Pull request has been created to address this issue:

          ## Test Environment PR
          **PR:** ${{ env.TEST_PR_URL }}

          ### Changes Made
          - Added ArgoCD application configuration to test environment
          - Created application Chart.yaml with dependencies
          - Created application values.yaml from source repository

          ### Next Steps
          - Review the pull request
          - Validate the application configuration
          - Test deployment in test environment
          - Merge once validated

          ## Summary
          - **Test Environment PR:** ${{ env.TEST_PR_URL }}

          Please review the pull request and merge once validated. The application will be deployed to the test environment after merging."

  argo-prod-changes:
    name: ArgoCD App Prod Changes
    if: ${{ needs.extract_info.outputs.environment == 'prod' || needs.extract_info.outputs.environment == 'both' }}
    needs: [extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Modify values.yaml for Prod Environment
        run: |
          # Generate the application name for prod environment
          APP_NAME="${{ needs.extract_info.outputs.application-name }}-prod"

          # Use yq to add the new application configuration
          yq eval ".applications.$APP_NAME = {\"project\": \"default\", \"source\": {\"path\": \"environments/prod/applications/${{ needs.extract_info.outputs.application-name }}\"}, \"destination\": {\"namespace\": \"prod\"}}" -i environments/prod/configuration/values.yaml

      - name: Commit changes
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository }}
          git checkout -b feature/new-application-${{ env.NAME }}-prod
          git add environments/prod/configuration/values.yaml
          git commit -m "Add ${{ needs.extract_info.outputs.application-name }} ArgoCD app to prod environment"
          git push origin feature/new-application-${{ env.NAME }}-prod

  app-config-prod-changes:
    name: Application Config Prod Changes
    needs: [argo-prod-changes, extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Create Application Chart.yaml
        run: |
          # Create the application directory
          mkdir -p environments/prod/applications/${{ needs.extract_info.outputs.application-name }}

          # Create Chart.yaml
          cat > environments/prod/applications/${{ needs.extract_info.outputs.application-name }}/Chart.yaml << EOF
          apiVersion: v2
          name: ${{ needs.extract_info.outputs.application-name }}
          version: 1.0.0
          description: Helm chart for ${{ needs.extract_info.outputs.application-name }} deployment
          dependencies:
            - name: ${{ needs.extract_info.outputs.helm-chart-name }}
              version: ${{ needs.extract_info.outputs.app-version }}
              repository: "http://3.238.99.68"
          EOF

      - name: Create Application values.yaml
        run: |
          # Clone the original repository to get the values.yaml
          git clone https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/unir-tfm-devops/${{ needs.extract_info.outputs.repository-name }}.git temp-repo
          cd temp-repo

          # Copy the values.yaml from the helm-chart-path and wrap it under the app name
          if [ -f ".${{ needs.extract_info.outputs.helm-path }}/values.yaml" ]; then
            # Use yq to create a new values.yaml with the app name as root key containing the original content
            yq eval ".${{ needs.extract_info.outputs.application-name }} = load(\".${{ needs.extract_info.outputs.helm-path }}/values.yaml\")" -n > ../environments/prod/applications/${{ needs.extract_info.outputs.application-name }}/values.yaml
            echo "Successfully copied and wrapped values.yaml from ${{ needs.extract_info.outputs.helm-path }}"
          else
            echo "Error: values.yaml not found at .${{ needs.extract_info.outputs.helm-path }}/values.yaml"
            exit 1
          fi

          # Clean up
          cd ..
          rm -rf temp-repo

      - name: Commit Application Config Changes
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository }}

          # Checkout the existing branch and pull latest changes
          git fetch origin
          git checkout feature/new-application-${{ env.NAME }}-prod
          git pull origin feature/new-application-${{ env.NAME }}-prod

          git add environments/prod/applications/${{ needs.extract_info.outputs.application-name }}/
          git commit -m "Add ${{ needs.extract_info.outputs.application-name }} application configuration for prod environment"
          git push origin feature/new-application-${{ env.NAME }}-prod

  create-prod-pr:
    name: Create Prod PR
    needs: [app-config-prod-changes, extract_info]
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ env.PR_URL }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Create Pull Request
        id: create_pr
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PR_URL=$(gh pr create \
            -B main \
            -H feature/new-application-${{ env.NAME }}-prod \
            -t "Add new application to prod environment: ${{ env.NAME }}" \
            -b "### Summary
            This PR adds a new application as requested in [Issue #${{ env.ISSUE_NUMBER }}](${{ env.ISSUE_URL }}).

            **Application Name:** ${{ env.NAME }}
            **Environment:** prod

            ### Changes Made
            - Added ArgoCD application configuration to prod environment
            - Created application Chart.yaml with dependencies
            - Created application values.yaml from source repository

            ### Checklist
            - [ ] Verify application name and configuration
            - [ ] Confirm Helm chart dependencies are correct
            - [ ] Validate ArgoCD application syntax
            - [ ] Merge once validated

            Closes #${{ env.ISSUE_NUMBER }}")

          echo "PR_URL=$PR_URL" >> $GITHUB_ENV

  comment-on-issue-prod:
    name: Comment on Issue Prod PR
    needs: [create-prod-pr]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Comment on Issue
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          PROD_PR_URL: ${{ needs.create-prod-pr.outputs.pr_url }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "✅ Pull request has been created to address this issue:

          ## Prod Environment PR
          **PR:** ${{ env.PROD_PR_URL }}

          ### Changes Made
          - Added ArgoCD application configuration to prod environment
          - Created application Chart.yaml with dependencies
          - Created application values.yaml from source repository

          ### Next Steps
          - Review the pull request
          - Validate the application configuration
          - Test deployment in prod environment
          - Merge once validated

          ## Summary
          - **Prod Environment PR:** ${{ env.PROD_PR_URL }}

          Please review the pull request and merge once validated. The application will be deployed to the prod environment after merging."

  rds-test-changes:
    name: RDS Test Changes
    needs: [extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.get_token.outputs.token }}
          repository: ${{ github.repository_owner }}/infra-rds
          path: infra-rds

      - name: Add new DB to test environment
        working-directory: infra-rds
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          # Add new Database module to databases-test.tf
          cat <<EOF >> databases-test.tf

          module "${{ env.NAME }}-test" {
            source = "./modules/database"

            database_name = "${{ env.NAME }}-test"
            username = "${{ env.NAME }}-test"
            password = "${{ env.NAME }}-test"

            depends_on = [time_sleep.wait_for_rds]

            provderis = {
              postgresql = postgresql.test
            }
          }
          EOF

      - name: Commit RDS database changes
        working-directory: infra-rds
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository_owner }}/infra-rds
          git checkout -b feature/new-test-db-${{ env.NAME }}
          git add databases-test.tf
          git commit -m "Add new DB for ${{ env.NAME }} in test environment"
          git push origin feature/new-test-db-${{ env.NAME }}

  create-rds-test-pr:
    name: Create RDS Test PR
    needs: [rds-test-changes, extract_info]
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ env.PR_URL }}
    steps:
      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "infra-rds"

      - name: Checkout infra-rds Repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.get_token.outputs.token }}
          repository: ${{ github.repository_owner }}/infra-rds

      - name: Create Pull Request
        id: create_pr
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PR_URL=$(gh pr create \
            -B main \
            -H feature/new-test-db-${{ env.NAME }} \
            -t "Add new database for ${{ env.NAME }} in test environment" \
            -b "### Summary
            This PR adds a new database as requested in [Issue #${{ env.ISSUE_NUMBER }}](${{ env.ISSUE_URL }}).

            **Application Name:** ${{ env.NAME }}
            **Environment:** test
            **Database Name:** ${{ env.NAME }}-test

            ### Changes Made
            - Added new database module configuration for test environment
            - Database name: ${{ env.NAME }}-test
            - Username: ${{ env.NAME }}-test

            ### Checklist
            - [ ] Verify database name and configuration
            - [ ] Confirm database credentials are correct
            - [ ] Validate Terraform syntax
            - [ ] Merge once validated

            Closes #${{ env.ISSUE_NUMBER }}")

          echo "PR_URL=$PR_URL" >> $GITHUB_ENV

  comment-on-issue-rds:
    name: Comment on Issue RDS PR
    needs: [create-rds-test-pr, extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Comment on Issue
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          RDS_PR_URL: ${{ needs.create-rds-test-pr.outputs.pr_url }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "✅ Database pull request has been created to address this issue:

          ## Database PR (Must be merged FIRST!)
          **PR:** ${{ env.RDS_PR_URL }}

          ### ⚠️ Important Merge Order
          **This database PR must be merged BEFORE the ArgoCD application PRs!**

          ### Changes Made
          - Added new database module configuration for test environment
          - Database name: ${{ needs.extract_info.outputs.application-name }}-test
          - Username: ${{ needs.extract_info.outputs.application-name }}-test

          ### Next Steps
          1. **Review and merge the database PR first**
          2. **Wait for database creation to complete**
          3. **Then review and merge the ArgoCD application PRs**

          ## Summary
          - **Database PR:** ${{ env.RDS_PR_URL }}

          Please merge the database PR first, then proceed with the application PRs once the database is ready."

  rds-prod-changes:
    name: RDS Prod Changes
    needs: [extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.get_token.outputs.token }}
          repository: ${{ github.repository_owner }}/infra-rds
          path: infra-rds

      - name: Add new DB to prod environment
        working-directory: infra-rds
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          # Add new Database module to databases-prod.tf
          cat <<EOF >> databases-prod.tf

          module "${{ env.NAME }}-prod" {
            source = "./modules/database"

            database_name = "${{ env.NAME }}-prod"
            username = "${{ env.NAME }}-prod"
            password = "${{ env.NAME }}-prod"

            depends_on = [time_sleep.wait_for_rds]

            provderis = {
              postgresql = postgresql.prod
            }
          }
          EOF

      - name: Commit RDS database changes
        working-directory: infra-rds
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
        run: |
          git config --global user.email "unir-tfm-devops[bot]@users.noreply.github.com"
          git config --global user.name "unir-tfm-devops[bot]"
          git remote set-url origin https://x-access-token:${{ steps.get_token.outputs.token }}@github.com/${{ github.repository_owner }}/infra-rds
          git checkout -b feature/new-prod-db-${{ env.NAME }}
          git add databases-prod.tf
          git commit -m "Add new DB for ${{ env.NAME }} in prod environment"
          git push origin feature/new-prod-db-${{ env.NAME }}

  create-rds-prod-pr:
    name: Create RDS Prod PR
    needs: [rds-prod-changes, extract_info]
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ env.PR_URL }}
    steps:
      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "infra-rds"

      - name: Checkout infra-rds Repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.get_token.outputs.token }}
          repository: ${{ github.repository_owner }}/infra-rds

      - name: Create Pull Request
        id: create_pr
        env:
          NAME: ${{ needs.extract_info.outputs.application-name }}
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PR_URL=$(gh pr create \
            -B main \
            -H feature/new-prod-db-${{ env.NAME }} \
            -t "Add new database for ${{ env.NAME }} in prod environment" \
            -b "### Summary
            This PR adds a new database as requested in [Issue #${{ env.ISSUE_NUMBER }}](${{ env.ISSUE_URL }}).

            **Application Name:** ${{ env.NAME }}
            **Environment:** prod
            **Database Name:** ${{ env.NAME }}-prod

            ### Changes Made
            - Added new database module configuration for prod environment
            - Database name: ${{ env.NAME }}-prod
            - Username: ${{ env.NAME }}-prod

            ### Checklist
            - [ ] Verify database name and configuration
            - [ ] Confirm database credentials are correct
            - [ ] Validate Terraform syntax
            - [ ] Merge once validated

            Closes #${{ env.ISSUE_NUMBER }}")

          echo "PR_URL=$PR_URL" >> $GITHUB_ENV

  comment-on-issue-rds-prod:
    name: Comment on Issue RDS Prod PR
    needs: [create-rds-prod-pr, extract_info]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Token From GitHub APP
        id: get_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.UNIR_TFM_APP_ID }}
          private-key: ${{ secrets.UNIR_TFM_APP_PRIVATE_KEY }}
          repositories: "eks-workloads"

      - name: Comment on Issue
        env:
          GITHUB_TOKEN: ${{ steps.get_token.outputs.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          RDS_PROD_PR_URL: ${{ needs.create-rds-prod-pr.outputs.pr_url }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "✅ Production database pull request has been created to address this issue:

          ## Production Database PR (Must be merged FIRST!)
          **PR:** ${{ env.RDS_PROD_PR_URL }}

          ### ⚠️ Important Merge Order
          **This production database PR must be merged BEFORE the production ArgoCD application PRs!**

          ### Changes Made
          - Added new database module configuration for prod environment
          - Database name: ${{ needs.extract_info.outputs.application-name }}-prod
          - Username: ${{ needs.extract_info.outputs.application-name }}-prod

          ### Next Steps
          1. **Review and merge the production database PR first**
          2. **Wait for database creation to complete**
          3. **Then review and merge the production ArgoCD application PRs**

          ## Summary
          - **Production Database PR:** ${{ env.RDS_PROD_PR_URL }}

          Please merge the production database PR first, then proceed with the production application PRs once the database is ready."
